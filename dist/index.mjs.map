{"version":3,"sources":["../src/utils/nsfw.ts","../src/core/Filter.ts","../src/core/Cache.ts","../src/utils/hash.ts","../src/core/Fetcher.ts","../src/utils/http.ts","../src/core/RateLimiter.ts","../src/sources/multiapi.ts","../src/discord/embed.ts","../src/core/MemeForge.ts"],"sourcesContent":["export function isNSFW(title: string, contentUrl: string, tags: string[] = []): boolean {\r\n    const nsfwKeywords = ['nsfw', 'porn', 'hentai', 'sexy', 'lewd', 'adult', 'xxx', '18+', 'nude'];\r\n    const textToTest = `${title} ${contentUrl} ${tags.join(' ')}`.toLowerCase();\r\n\r\n    return nsfwKeywords.some(keyword => textToTest.includes(keyword));\r\n}\r\n\r\nexport function hasNSFWContent(meme: { title: string; url: string; nsfw: boolean; subreddit?: string }): boolean {\r\n    if (meme.nsfw) return true;\r\n    \r\n    const nsfwSubreddits = ['nsfw', 'gonewild', 'rule34', 'hentai', 'porn'];\r\n    if (meme.subreddit && nsfwSubreddits.some(sub => meme.subreddit?.toLowerCase().includes(sub))) {\r\n        return true;\r\n    }\r\n    \r\n    return isNSFW(meme.title, meme.url);\r\n}","import { Meme, MemeFilter } from '../types';\r\nimport { hasNSFWContent } from '../utils/nsfw';\r\n\r\nexport class Filter {\r\n    static apply(memes: Meme[], filter: MemeFilter): Meme[] {\r\n        return memes.filter((meme) => {\r\n            if (filter.nsfw === false && (meme.nsfw || hasNSFWContent(meme))) {\r\n                return false;\r\n            }\r\n\r\n            if (filter.minUpvotes && meme.upvotes < filter.minUpvotes) {\r\n                return false;\r\n            }\r\n\r\n            if (filter.mediaType && filter.mediaType !== 'any' && meme.mediaType !== filter.mediaType) {\r\n                return false;\r\n            }\r\n\r\n            if (filter.subreddits && filter.subreddits.length > 0 && meme.subreddit) {\r\n                if (!filter.subreddits.map(s => s.toLowerCase()).includes(meme.subreddit.toLowerCase())) {\r\n                    return false;\r\n                }\r\n            }\r\n\r\n            return true;\r\n        });\r\n    }\r\n\r\n    static paginate(memes: Meme[], limit?: number): Meme[] {\r\n        if (!limit || limit <= 0) return memes;\r\n        return memes.slice(0, limit);\r\n    }\r\n}","export interface CacheEntry<T> {\r\n    data: T;\r\n    expiry: number;\r\n}\r\n\r\nexport class Cache {\r\n    private store: Map<string, CacheEntry<any>> = new Map();\r\n    private defaultTTL: number;\r\n\r\n    constructor(defaultTTLSeconds = 3600) {\r\n        this.defaultTTL = defaultTTLSeconds * 1000;\r\n    }\r\n\r\n    set<T>(key: string, data: T, ttlSeconds?: number): void {\r\n        const ttl = (ttlSeconds !== undefined ? ttlSeconds * 1000 : this.defaultTTL);\r\n        this.store.set(key, {\r\n            data,\r\n            expiry: Date.now() + ttl,\r\n        });\r\n    }\r\n\r\n    get<T>(key: string): T | null {\r\n        const entry = this.store.get(key);\r\n        if (!entry) return null;\r\n\r\n        if (Date.now() > entry.expiry) {\r\n            this.store.delete(key);\r\n            return null;\r\n        }\r\n\r\n        return entry.data as T;\r\n    }\r\n\r\n    delete(key: string): void {\r\n        this.store.delete(key);\r\n    }\r\n\r\n    clear(): void {\r\n        this.store.clear();\r\n    }\r\n\r\n    /**\r\n     * Periodic cleanup of expired entries\r\n     */\r\n    prune(): void {\r\n        const now = Date.now();\r\n        for (const [key, entry] of this.store.entries()) {\r\n            if (now > entry.expiry) {\r\n                this.store.delete(key);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nexport const cache = new Cache();\r\n","export function generateHash(input: string): string {\r\n    let hash = 0;\r\n    for (let i = 0; i < input.length; i++) {\r\n        const char = input.charCodeAt(i);\r\n        hash = ((hash << 5) - hash) + char;\r\n        hash = hash & hash;\r\n    }\r\n    return Math.abs(hash).toString(36);\r\n}\r\n\r\nexport function isDuplicate(url1: string, url2: string): boolean {\r\n    try {\r\n        const u1 = new URL(url1);\r\n        const u2 = new URL(url2);\r\n\r\n        return u1.hostname.replace('i.', '') === u2.hostname.replace('i.', '') &&\r\n            u1.pathname === u2.pathname;\r\n    } catch {\r\n        return url1 === url2;\r\n    }\r\n}","import { Meme, FetchOptions, ISourceHandler } from '../types';\r\nimport { Filter } from './Filter';\r\nimport { cache } from './Cache';\r\nimport { generateHash } from '../utils/hash';\r\n\r\nexport class Fetcher {\r\n    private sources: Map<string, ISourceHandler> = new Map();\r\n\r\n    registerSource(handler: ISourceHandler): void {\r\n        this.sources.set(handler.name, handler);\r\n    }\r\n\r\n    async fetch(options: FetchOptions): Promise<Meme[]> {\r\n        const sourceName = options.source || 'reddit';\r\n        const handler = this.sources.get(sourceName);\r\n\r\n        if (!handler) {\r\n            throw new Error(`Source handler for '${sourceName}' not found`);\r\n        }\r\n\r\n        const cacheKey = generateHash(`${sourceName}-${JSON.stringify(options)}`);\r\n\r\n        if (options.cache !== false) {\r\n            const cached = cache.get<Meme[]>(cacheKey);\r\n            if (cached) return cached;\r\n        }\r\n\r\n        let memes = await handler.fetch(options);\r\n\r\n        // Apply filters\r\n        memes = Filter.apply(memes, options);\r\n\r\n        // Limit results\r\n        memes = Filter.paginate(memes, options.limit);\r\n\r\n        if (options.cache !== false) {\r\n            cache.set(cacheKey, memes);\r\n        }\r\n\r\n        return memes;\r\n    }\r\n}\r\n\r\nexport const fetcher = new Fetcher();\r\n","import axios, { AxiosRequestConfig, AxiosInstance } from 'axios';\r\n\r\nconst USER_AGENTS = [\r\n    'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',\r\n    'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',\r\n    'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',\r\n    'Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:121.0) Gecko/20100101 Firefox/121.0',\r\n    'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/17.1 Safari/605.1.15'\r\n];\r\n\r\nfunction getRandomUserAgent(): string {\r\n    return USER_AGENTS[Math.floor(Math.random() * USER_AGENTS.length)];\r\n}\r\n\r\nexport class HttpClient {\r\n    private client: AxiosInstance;\r\n\r\n    constructor(baseURL?: string) {\r\n        this.client = axios.create({\r\n            baseURL,\r\n            timeout: 15000,\r\n            validateStatus: (status) => status < 500\r\n        });\r\n    }\r\n\r\n    async get<T>(url: string, config?: AxiosRequestConfig, retries = 3): Promise<T> {\r\n        const headers = {\r\n            'User-Agent': getRandomUserAgent(),\r\n            'Accept': 'application/json',\r\n            'Accept-Language': 'en-US,en;q=0.9,es;q=0.8',\r\n            'Accept-Encoding': 'gzip, deflate, br',\r\n            'Cache-Control': 'no-cache',\r\n            'Pragma': 'no-cache',\r\n            'Sec-Fetch-Dest': 'empty',\r\n            'Sec-Fetch-Mode': 'cors',\r\n            'Sec-Fetch-Site': 'same-origin',\r\n            ...config?.headers\r\n        };\r\n\r\n        try {\r\n            const response = await this.client.get<T>(url, {\r\n                ...config,\r\n                headers\r\n            });\r\n            \r\n            if (response.status === 404 || response.status === 403 || response.status === 429) {\r\n                throw new Error(`Request failed with status ${response.status}`);\r\n            }\r\n            \r\n            return response.data;\r\n        } catch (error: any) {\r\n            if (retries > 0 && this.isRetryable(error)) {\r\n                const backoffTime = (4 - retries) * 3000;\r\n                await this.delay(backoffTime);\r\n                return this.get<T>(url, config, retries - 1);\r\n            }\r\n            throw this.normalizeError(error);\r\n        }\r\n    }\r\n\r\n    private isRetryable(error: any): boolean {\r\n        return (\r\n            error.response?.status === 429 ||\r\n            error.response?.status === 503 ||\r\n            error.response?.status >= 500 ||\r\n            error.code === 'ECONNRESET' ||\r\n            error.code === 'ETIMEDOUT' ||\r\n            error.code === 'ECONNREFUSED' ||\r\n            !error.response\r\n        );\r\n    }\r\n\r\n    private delay(ms: number): Promise<void> {\r\n        return new Promise(resolve => setTimeout(resolve, ms));\r\n    }\r\n\r\n    private normalizeError(error: any): Error {\r\n        if (error.response) {\r\n            return new Error(\r\n                `Request failed with status ${error.response.status}: ${JSON.stringify(error.response.data)}`\r\n            );\r\n        }\r\n        if (error.code) {\r\n            return new Error(`Network error: ${error.code} - ${error.message}`);\r\n        }\r\n        return error;\r\n    }\r\n}\r\n\r\nexport const http = new HttpClient();","export class RateLimiter {\r\n    private lastRequestTime: Map<string, number> = new Map();\r\n    private minInterval: number;\r\n\r\n    constructor(requestsPerSecond = 0.5) {\r\n        this.minInterval = 1000 / requestsPerSecond;\r\n    }\r\n\r\n    async throttle(key: string): Promise<void> {\r\n        const now = Date.now();\r\n        const lastTime = this.lastRequestTime.get(key) || 0;\r\n        const timeSinceLastRequest = now - lastTime;\r\n\r\n        if (timeSinceLastRequest < this.minInterval) {\r\n            const waitTime = this.minInterval - timeSinceLastRequest;\r\n            await new Promise((resolve) => setTimeout(resolve, waitTime));\r\n        }\r\n\r\n        this.lastRequestTime.set(key, Date.now());\r\n    }\r\n}\r\n\r\nexport const rateLimiter = new RateLimiter();","import { ISourceHandler, FetchOptions, Meme, MediaType } from '../types';\nimport { http } from '../utils/http';\nimport { rateLimiter } from '../core/RateLimiter';\n\ninterface WantCatResponse {\n    url: string;\n    title?: string;\n}\n\ninterface MemesAPIResponse {\n    url: string;\n    title?: string;\n    author?: string;\n}\n\nexport class MultiAPISource implements ISourceHandler {\n    name = 'multiapi';\n    private recentMemeIds: Set<string> = new Set();\n    private maxRecentIds = 150;\n    private memeCache: Meme[] = [];\n    private lastFetchTime = 0;\n    private cacheDuration = 180000;\n\n    async fetch(options: FetchOptions): Promise<Meme[]> {\n        const now = Date.now();\n        \n        if (this.memeCache.length > 10 && now - this.lastFetchTime < this.cacheDuration) {\n            const cached = [...this.memeCache].sort(() => Math.random() - 0.5);\n            return cached.slice(0, options.limit || 20);\n        }\n\n        await rateLimiter.throttle('multiapi');\n\n        const apis = [\n            { \n                url: 'https://api.want.cat/api/memes',\n                type: 'want',\n                count: 1\n            },\n            { \n                url: 'https://meme-api.com/gimme/MAAU/20',\n                type: 'reddit',\n                count: 20\n            },\n            { \n                url: 'https://meme-api.com/gimme/yo_elvr/20',\n                type: 'reddit',\n                count: 20\n            },\n            { \n                url: 'https://meme-api.com/gimme/LatinoPeopleTwitter/20',\n                type: 'reddit',\n                count: 20\n            }\n        ];\n\n        const allMemes: Meme[] = [];\n\n        for (const api of apis) {\n            try {\n                if (api.type === 'want') {\n                    for (let i = 0; i < 20; i++) {\n                        const response = await http.get<WantCatResponse>(api.url, { timeout: 8000 });\n                        if (response?.url) {\n                            const meme = this.mapWantCatToMeme(response, i);\n                            if (meme) allMemes.push(meme);\n                        }\n                        await new Promise(resolve => setTimeout(resolve, 200));\n                    }\n                } else if (api.type === 'reddit') {\n                    const response = await http.get<{ memes: any[] }>(api.url, { timeout: 10000 });\n                    if (response?.memes && Array.isArray(response.memes)) {\n                        const memes = response.memes\n                            .map((item, idx) => this.mapRedditAPIToMeme(item, idx))\n                            .filter((meme): meme is Meme => meme !== null);\n                        allMemes.push(...memes);\n                    }\n                }\n            } catch (error: any) {\n                console.error(`Error fetching from ${api.url}:`, error.message);\n                continue;\n            }\n        }\n\n        if (allMemes.length > 0) {\n            this.memeCache = allMemes;\n            this.lastFetchTime = now;\n            \n            const uniqueMemes: Meme[] = [];\n            for (const meme of allMemes) {\n                if (!this.recentMemeIds.has(meme.id)) {\n                    uniqueMemes.push(meme);\n                    this.recentMemeIds.add(meme.id);\n\n                    if (this.recentMemeIds.size > this.maxRecentIds) {\n                        const firstId = this.recentMemeIds.values().next().value;\n                        if (firstId) this.recentMemeIds.delete(firstId);\n                    }\n                }\n            }\n\n            return uniqueMemes.sort(() => Math.random() - 0.5);\n        }\n\n        if (this.memeCache.length > 0) {\n            return [...this.memeCache].sort(() => Math.random() - 0.5).slice(0, options.limit || 20);\n        }\n\n        return [];\n    }\n\n    private mapWantCatToMeme(response: WantCatResponse, index: number): Meme | null {\n        if (!response.url) return null;\n\n        const id = `want_${Date.now()}_${index}_${response.url.split('/').pop()}`;\n\n        return {\n            id,\n            title: response.title || 'Meme',\n            url: response.url,\n            sourceUrl: 'https://want.cat',\n            author: 'want.cat',\n            upvotes: 0,\n            nsfw: false,\n            spoiler: false,\n            mediaType: 'image',\n            createdAt: Date.now(),\n            source: 'want'\n        };\n    }\n\n    private mapRedditAPIToMeme(item: any, index: number): Meme | null {\n        if (!item.url || item.nsfw) {\n            return null;\n        }\n\n        const mediaType = this.getMediaType(item.url);\n        if (!mediaType || mediaType === 'video') {\n            return null;\n        }\n\n        const id = item.postLink ? item.postLink.split('/').pop() || `meme_${Date.now()}_${index}` : `meme_${Date.now()}_${index}`;\n\n        return {\n            id,\n            title: item.title || 'Meme',\n            url: item.url,\n            sourceUrl: item.postLink || 'https://reddit.com',\n            author: item.author || 'unknown',\n            subreddit: item.subreddit,\n            upvotes: item.ups || 0,\n            nsfw: item.nsfw || false,\n            spoiler: item.spoiler || false,\n            mediaType,\n            createdAt: Date.now(),\n            source: 'reddit'\n        };\n    }\n\n    private getMediaType(url: string): MediaType | null {\n        if (url.match(/\\.(jpg|jpeg|png|webp)/i) || url.includes('i.redd.it')) {\n            return 'image';\n        }\n        if (url.match(/\\.(gif|gifv)/i)) {\n            return 'gif';\n        }\n        if (url.includes('v.redd.it') || url.match(/\\.(mp4|webm|mov)/i)) {\n            return 'video';\n        }\n        return null;\n    }\n}\n","import { Meme, DiscordEmbed } from '../types';\r\n\r\nexport class DiscordFormatter {\r\n    /**\r\n     * Converts a Meme object to a Discord embed object\r\n     */\r\n    static toEmbed(meme: Meme): DiscordEmbed {\r\n        return {\r\n            title: this.truncate(meme.title, 256),\r\n            url: meme.sourceUrl,\r\n            image: {\r\n                url: meme.url,\r\n            },\r\n            color: 0xff4500, // Reddit Orange\r\n            author: {\r\n                name: `u/${meme.author}${meme.subreddit ? ` (r/${meme.subreddit})` : ''}`,\r\n                url: `https://reddit.com/u/${meme.author}`,\r\n            },\r\n            footer: {\r\n                text: `ðŸ‘ ${meme.upvotes.toLocaleString()} â€¢ Source: ${meme.source}`,\r\n            },\r\n            timestamp: new Date(meme.createdAt).toISOString(),\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Truncate strings to fit Discord's limits\r\n     */\r\n    private static truncate(str: string, limit: number): string {\r\n        return str.length > limit ? str.substring(0, limit - 3) + '...' : str;\r\n    }\r\n}\r\n","import { FetchOptions, ISourceHandler, Meme, DiscordEmbed } from '../types';\r\nimport { fetcher } from './Fetcher';\r\nimport { MultiAPISource } from '../sources/multiapi';\r\nimport { DiscordFormatter } from '../discord/embed';\r\n\r\nexport class MemeForge {\r\n    constructor() {\r\n        this.registerSource(new MultiAPISource());\r\n    }\r\n\r\n    registerSource(handler: ISourceHandler): void {\r\n        fetcher.registerSource(handler);\r\n    }\r\n\r\n    async fetch(options: FetchOptions = {}): Promise<Meme[] | DiscordEmbed[]> {\r\n        if (!options.source) {\r\n            options.source = 'multiapi';\r\n        }\r\n\r\n        const memes = await fetcher.fetch(options);\r\n\r\n        if (options.format === 'discord-embed') {\r\n            return memes.map(meme => DiscordFormatter.toEmbed(meme));\r\n        }\r\n\r\n        return memes;\r\n    }\r\n\r\n    async fetchOne(options: FetchOptions = {}): Promise<Meme | DiscordEmbed | null> {\r\n        const results = await this.fetch({ ...options, limit: 1 });\r\n        return results.length > 0 ? results[0] : null;\r\n    }\r\n}\r\n\r\nexport const memeForge = new MemeForge();"],"mappings":"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","names":["isNSFW","title","contentUrl","tags","nsfwKeywords","textToTest","keyword","hasNSFWContent","meme","nsfwSubreddits","sub","Filter","memes","filter","meme","hasNSFWContent","s","limit","Cache","defaultTTLSeconds","key","data","ttlSeconds","ttl","entry","now","cache","generateHash","input","hash","i","char","isDuplicate","url1","url2","u1","u2","Fetcher","handler","options","sourceName","cacheKey","generateHash","cached","cache","memes","Filter","fetcher","axios","USER_AGENTS","getRandomUserAgent","HttpClient","baseURL","status","url","config","retries","headers","response","error","backoffTime","ms","resolve","http","RateLimiter","requestsPerSecond","key","now","lastTime","timeSinceLastRequest","waitTime","resolve","rateLimiter","MultiAPISource","options","now","rateLimiter","apis","allMemes","api","i","response","http","meme","resolve","memes","item","idx","error","uniqueMemes","firstId","index","mediaType","url","DiscordFormatter","meme","str","limit","MemeForge","MultiAPISource","handler","fetcher","options","memes","meme","DiscordFormatter","results","memeForge"]}