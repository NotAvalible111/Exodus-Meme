{"version":3,"sources":["../src/index.ts","../src/utils/nsfw.ts","../src/core/Filter.ts","../src/core/Cache.ts","../src/utils/hash.ts","../src/core/Fetcher.ts","../src/utils/http.ts","../src/core/RateLimiter.ts","../src/sources/reddit.ts","../src/discord/embed.ts","../src/core/MemeForge.ts"],"sourcesContent":["export * from './types';\r\nexport * from './core/MemeForge';\r\nexport * from './core/Fetcher';\r\nexport * from './core/Filter';\r\nexport * from './core/Cache';\r\nexport * from './core/RateLimiter';\r\nexport * from './sources/reddit';\r\nexport * from './discord/embed';\r\nexport * from './utils/http';\r\nexport * from './utils/hash';\r\nexport * from './utils/nsfw';","export function isNSFW(title: string, contentUrl: string, tags: string[] = []): boolean {\r\n    const nsfwKeywords = ['nsfw', 'porn', 'hentai', 'sexy', 'lewd', 'adult', 'xxx', '18+', 'nude'];\r\n    const textToTest = `${title} ${contentUrl} ${tags.join(' ')}`.toLowerCase();\r\n\r\n    return nsfwKeywords.some(keyword => textToTest.includes(keyword));\r\n}\r\n\r\nexport function hasNSFWContent(meme: { title: string; url: string; nsfw: boolean; subreddit?: string }): boolean {\r\n    if (meme.nsfw) return true;\r\n    \r\n    const nsfwSubreddits = ['nsfw', 'gonewild', 'rule34', 'hentai', 'porn'];\r\n    if (meme.subreddit && nsfwSubreddits.some(sub => meme.subreddit?.toLowerCase().includes(sub))) {\r\n        return true;\r\n    }\r\n    \r\n    return isNSFW(meme.title, meme.url);\r\n}","import { Meme, MemeFilter } from '../types';\r\nimport { hasNSFWContent } from '../utils/nsfw';\r\n\r\nexport class Filter {\r\n    static apply(memes: Meme[], filter: MemeFilter): Meme[] {\r\n        return memes.filter((meme) => {\r\n            if (filter.nsfw === false && (meme.nsfw || hasNSFWContent(meme))) {\r\n                return false;\r\n            }\r\n\r\n            if (filter.minUpvotes && meme.upvotes < filter.minUpvotes) {\r\n                return false;\r\n            }\r\n\r\n            if (filter.mediaType && filter.mediaType !== 'any' && meme.mediaType !== filter.mediaType) {\r\n                return false;\r\n            }\r\n\r\n            if (filter.subreddits && filter.subreddits.length > 0 && meme.subreddit) {\r\n                if (!filter.subreddits.map(s => s.toLowerCase()).includes(meme.subreddit.toLowerCase())) {\r\n                    return false;\r\n                }\r\n            }\r\n\r\n            return true;\r\n        });\r\n    }\r\n\r\n    static paginate(memes: Meme[], limit?: number): Meme[] {\r\n        if (!limit || limit <= 0) return memes;\r\n        return memes.slice(0, limit);\r\n    }\r\n}","export interface CacheEntry<T> {\r\n    data: T;\r\n    expiry: number;\r\n}\r\n\r\nexport class Cache {\r\n    private store: Map<string, CacheEntry<any>> = new Map();\r\n    private defaultTTL: number;\r\n\r\n    constructor(defaultTTLSeconds = 3600) {\r\n        this.defaultTTL = defaultTTLSeconds * 1000;\r\n    }\r\n\r\n    set<T>(key: string, data: T, ttlSeconds?: number): void {\r\n        const ttl = (ttlSeconds !== undefined ? ttlSeconds * 1000 : this.defaultTTL);\r\n        this.store.set(key, {\r\n            data,\r\n            expiry: Date.now() + ttl,\r\n        });\r\n    }\r\n\r\n    get<T>(key: string): T | null {\r\n        const entry = this.store.get(key);\r\n        if (!entry) return null;\r\n\r\n        if (Date.now() > entry.expiry) {\r\n            this.store.delete(key);\r\n            return null;\r\n        }\r\n\r\n        return entry.data as T;\r\n    }\r\n\r\n    delete(key: string): void {\r\n        this.store.delete(key);\r\n    }\r\n\r\n    clear(): void {\r\n        this.store.clear();\r\n    }\r\n\r\n    /**\r\n     * Periodic cleanup of expired entries\r\n     */\r\n    prune(): void {\r\n        const now = Date.now();\r\n        for (const [key, entry] of this.store.entries()) {\r\n            if (now > entry.expiry) {\r\n                this.store.delete(key);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nexport const cache = new Cache();\r\n","import { createHash } from 'crypto';\r\n\r\n/**\r\n * Generates a simple SHA-256 hash for a given string (usually a URL or post ID)\r\n * This is used for basic duplicate detection in the cache.\r\n */\r\nexport function generateHash(input: string): string {\r\n    return createHash('sha256').update(input).digest('hex');\r\n}\r\n\r\n/**\r\n * Compares two URLs to see if they might be the same image, \r\n * even if they have different subdomains or query params.\r\n */\r\nexport function isDuplicate(url1: string, url2: string): boolean {\r\n    try {\r\n        const u1 = new URL(url1);\r\n        const u2 = new URL(url2);\r\n\r\n        // Normalize by Removing query params and comparing pathname\r\n        return u1.hostname.replace('i.', '') === u2.hostname.replace('i.', '') &&\r\n            u1.pathname === u2.pathname;\r\n    } catch {\r\n        return url1 === url2;\r\n    }\r\n}\r\n","import { Meme, FetchOptions, ISourceHandler } from '../types';\r\nimport { Filter } from './Filter';\r\nimport { cache } from './Cache';\r\nimport { generateHash } from '../utils/hash';\r\n\r\nexport class Fetcher {\r\n    private sources: Map<string, ISourceHandler> = new Map();\r\n\r\n    registerSource(handler: ISourceHandler): void {\r\n        this.sources.set(handler.name, handler);\r\n    }\r\n\r\n    async fetch(options: FetchOptions): Promise<Meme[]> {\r\n        const sourceName = options.source || 'reddit';\r\n        const handler = this.sources.get(sourceName);\r\n\r\n        if (!handler) {\r\n            throw new Error(`Source handler for '${sourceName}' not found`);\r\n        }\r\n\r\n        const cacheKey = generateHash(`${sourceName}-${JSON.stringify(options)}`);\r\n\r\n        if (options.cache !== false) {\r\n            const cached = cache.get<Meme[]>(cacheKey);\r\n            if (cached) return cached;\r\n        }\r\n\r\n        let memes = await handler.fetch(options);\r\n\r\n        // Apply filters\r\n        memes = Filter.apply(memes, options);\r\n\r\n        // Limit results\r\n        memes = Filter.paginate(memes, options.limit);\r\n\r\n        if (options.cache !== false) {\r\n            cache.set(cacheKey, memes);\r\n        }\r\n\r\n        return memes;\r\n    }\r\n}\r\n\r\nexport const fetcher = new Fetcher();\r\n","import axios, { AxiosInstance, AxiosRequestConfig } from 'axios';\r\n\r\nconst DEFAULT_USER_AGENT = 'MemeForge/1.0.0 (https://github.com/PhoenixUchiha/Meme-Forge)';\r\n\r\nexport class HttpClient {\r\n    private client: AxiosInstance;\r\n\r\n    constructor(baseURL?: string) {\r\n        this.client = axios.create({\r\n            baseURL,\r\n            headers: {\r\n                'User-Agent': DEFAULT_USER_AGENT,\r\n            },\r\n            timeout: 10000,\r\n        });\r\n    }\r\n\r\n    async get<T>(url: string, config?: AxiosRequestConfig, retries = 3): Promise<T> {\r\n        try {\r\n            const response = await this.client.get<T>(url, config);\r\n            return response.data;\r\n        } catch (error: any) {\r\n            if (retries > 0 && this.isRetryable(error)) {\r\n                await this.delay(1000 * (4 - retries));\r\n                return this.get<T>(url, config, retries - 1);\r\n            }\r\n            throw this.normalizeError(error);\r\n        }\r\n    }\r\n\r\n    private isRetryable(error: any): boolean {\r\n        return error.response?.status === 429 || error.response?.status >= 500 || !error.response;\r\n    }\r\n\r\n    private delay(ms: number): Promise<void> {\r\n        return new Promise((resolve) => setTimeout(resolve, ms));\r\n    }\r\n\r\n    private normalizeError(error: any): Error {\r\n        if (error.response) {\r\n            return new Error(`Request failed with status ${error.response.status}: ${JSON.stringify(error.response.data)}`);\r\n        }\r\n        return error;\r\n    }\r\n}\r\n\r\nexport const http = new HttpClient();\r\n","export class RateLimiter {\r\n    private lastRequestTime: Map<string, number> = new Map();\r\n    private minInterval: number;\r\n\r\n    constructor(requestsPerSecond = 2) {\r\n        this.minInterval = 1000 / requestsPerSecond;\r\n    }\r\n\r\n    async throttle(key: string): Promise<void> {\r\n        const now = Date.now();\r\n        const lastTime = this.lastRequestTime.get(key) || 0;\r\n        const timeSinceLastRequest = now - lastTime;\r\n\r\n        if (timeSinceLastRequest < this.minInterval) {\r\n            const waitTime = this.minInterval - timeSinceLastRequest;\r\n            await new Promise((resolve) => setTimeout(resolve, waitTime));\r\n        }\r\n\r\n        this.lastRequestTime.set(key, Date.now());\r\n    }\r\n}\r\n\r\nexport const rateLimiter = new RateLimiter();\r\n","import { ISourceHandler, Meme, FetchOptions, MediaType } from '../types';\r\nimport { http } from '../utils/http';\r\nimport { rateLimiter } from '../core/RateLimiter';\r\n\r\nconst SPANISH_SUBREDDITS = ['yo_elvr', 'LatinoPeopleTwitter', 'MAAU', 'orslokx', 'DylanteroYT', 'Mujico', 'PeruMemes', 'PERU', 'espanol', 'MemesMexicanos'];\r\nconst ENGLISH_SUBREDDITS = ['memes', 'dankmemes', 'me_irl', 'wholesomememes', 'meirl', 'ProgrammerHumor', 'funny', 'meme'];\r\n\r\nexport class RedditSource implements ISourceHandler {\r\n    name = 'reddit';\r\n    private recentMemeIds: Set<string> = new Set();\r\n    private maxRecentIds = 500;\r\n\r\n    async fetch(options: FetchOptions): Promise<Meme[]> {\r\n        let subreddits: string[];\r\n        \r\n        if (options.subreddits && options.subreddits.length > 0) {\r\n            subreddits = options.subreddits;\r\n        } else if (options.language === 'es') {\r\n            subreddits = SPANISH_SUBREDDITS;\r\n        } else if (options.language === 'en') {\r\n            subreddits = ENGLISH_SUBREDDITS;\r\n        } else {\r\n            subreddits = [...SPANISH_SUBREDDITS, ...ENGLISH_SUBREDDITS];\r\n        }\r\n\r\n        const shuffledSubreddits = [...subreddits].sort(() => Math.random() - 0.5);\r\n        const subredditsToFetch = shuffledSubreddits.slice(0, Math.min(3, shuffledSubreddits.length));\r\n\r\n        const allMemes: Meme[] = [];\r\n\r\n        for (const subreddit of subredditsToFetch) {\r\n            await rateLimiter.throttle('reddit');\r\n\r\n            const sortOptions = ['hot', 'top'];\r\n            const sort = sortOptions[Math.floor(Math.random() * sortOptions.length)];\r\n            const timeParam = sort === 'top' ? '&t=day' : '';\r\n            const url = `https://www.reddit.com/r/${subreddit}/${sort}.json?limit=50${timeParam}`;\r\n            \r\n            try {\r\n                const data = await http.get<any>(url);\r\n\r\n                if (data?.data?.children) {\r\n                    const memes = data.data.children\r\n                        .map((child: any) => this.mapToMeme(child.data))\r\n                        .filter((meme: Meme | null) => meme !== null) as Meme[];\r\n                    \r\n                    allMemes.push(...memes);\r\n                }\r\n            } catch (error: any) {\r\n                if (error.message?.includes('404') || error.message?.includes('banned')) {\r\n                    //console.warn(`Subreddit r/${subreddit} no disponible, saltando...`);\r\n                } else {\r\n                    //console.error(`Error obteniendo de r/${subreddit}:`, error.message);\r\n                }\r\n            }\r\n        }\r\n\r\n        const newMemes: Meme[] = [];\r\n        \r\n        for (const meme of allMemes) {\r\n            if (!this.recentMemeIds.has(meme.id)) {\r\n                newMemes.push(meme);\r\n                this.recentMemeIds.add(meme.id);\r\n                \r\n                if (this.recentMemeIds.size > this.maxRecentIds) {\r\n                    const firstId = this.recentMemeIds.values().next().value;\r\n                    if (firstId) {\r\n                        this.recentMemeIds.delete(firstId);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        return newMemes.sort(() => Math.random() - 0.5);\r\n    }\r\n\r\n    private mapToMeme(data: any): Meme | null {\r\n        if (!data.url || data.is_self) return null;\r\n\r\n        let finalUrl = data.url;\r\n        let isVideo = false;\r\n\r\n        if (data.is_video && data.media?.reddit_video?.fallback_url) {\r\n            finalUrl = data.media.reddit_video.fallback_url;\r\n            isVideo = true;\r\n        }\r\n\r\n        const mediaType = isVideo ? 'video' : this.getMediaType(finalUrl);\r\n        if (!mediaType) return null;\r\n\r\n        return {\r\n            id: data.id,\r\n            title: data.title,\r\n            url: finalUrl,\r\n            sourceUrl: `https://reddit.com${data.permalink}`,\r\n            author: data.author,\r\n            subreddit: data.subreddit,\r\n            upvotes: data.ups,\r\n            nsfw: data.over_18,\r\n            spoiler: data.spoiler,\r\n            mediaType,\r\n            createdAt: data.created_utc * 1000,\r\n            width: data.media?.reddit_video?.width || data.preview?.images?.[0]?.source?.width,\r\n            height: data.media?.reddit_video?.height || data.preview?.images?.[0]?.source?.height,\r\n            source: 'reddit',\r\n        };\r\n    }\r\n\r\n    private getMediaType(url: string): MediaType | null {\r\n        if (url.match(/\\.(jpg|jpeg|png|webp)/i)) return 'image';\r\n        if (url.match(/\\.(gif|gifv)/i)) return 'gif';\r\n        if (url.includes('v.redd.it') || url.match(/\\.(mp4|webm|mov)/i)) return 'video';\r\n        return null;\r\n    }\r\n}","import { Meme, DiscordEmbed } from '../types';\r\n\r\nexport class DiscordFormatter {\r\n    /**\r\n     * Converts a Meme object to a Discord embed object\r\n     */\r\n    static toEmbed(meme: Meme): DiscordEmbed {\r\n        return {\r\n            title: this.truncate(meme.title, 256),\r\n            url: meme.sourceUrl,\r\n            image: {\r\n                url: meme.url,\r\n            },\r\n            color: 0xff4500, // Reddit Orange\r\n            author: {\r\n                name: `u/${meme.author}${meme.subreddit ? ` (r/${meme.subreddit})` : ''}`,\r\n                url: `https://reddit.com/u/${meme.author}`,\r\n            },\r\n            footer: {\r\n                text: `ðŸ‘ ${meme.upvotes.toLocaleString()} â€¢ Source: ${meme.source}`,\r\n            },\r\n            timestamp: new Date(meme.createdAt).toISOString(),\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Truncate strings to fit Discord's limits\r\n     */\r\n    private static truncate(str: string, limit: number): string {\r\n        return str.length > limit ? str.substring(0, limit - 3) + '...' : str;\r\n    }\r\n}\r\n","import { FetchOptions, ISourceHandler, Meme, DiscordEmbed } from '../types';\r\nimport { fetcher } from './Fetcher';\r\nimport { RedditSource } from '../sources/reddit';\r\nimport { DiscordFormatter } from '../discord/embed';\r\n\r\nexport class MemeForge {\r\n    constructor() {\r\n        // Register default sources\r\n        this.registerSource(new RedditSource());\r\n    }\r\n\r\n    /**\r\n     * Register a custom meme source\r\n     */\r\n    registerSource(handler: ISourceHandler): void {\r\n        fetcher.registerSource(handler);\r\n    }\r\n\r\n    /**\r\n     * Fetch memes based on options\r\n     */\r\n    async fetch(options: FetchOptions = {}): Promise<Meme[] | DiscordEmbed[]> {\r\n        const memes = await fetcher.fetch(options);\r\n\r\n        if (options.format === 'discord-embed') {\r\n            return memes.map(meme => DiscordFormatter.toEmbed(meme));\r\n        }\r\n\r\n        return memes;\r\n    }\r\n\r\n    /**\r\n     * Helper to fetch a single random meme\r\n     */\r\n    async fetchOne(options: FetchOptions = {}): Promise<Meme | DiscordEmbed | null> {\r\n        const results = await this.fetch({ ...options, limit: 1 });\r\n        return results.length > 0 ? results[0] : null;\r\n    }\r\n}\r\n\r\nexport const memeForge = new MemeForge();\r\n"],"mappings":"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","names":["index_exports","__export","Cache","DiscordFormatter","Fetcher","Filter","HttpClient","MemeForge","RateLimiter","RedditSource","cache","fetcher","generateHash","hasNSFWContent","http","isDuplicate","isNSFW","memeForge","rateLimiter","__toCommonJS","isNSFW","title","contentUrl","tags","nsfwKeywords","textToTest","keyword","hasNSFWContent","meme","nsfwSubreddits","sub","Filter","memes","filter","meme","hasNSFWContent","s","limit","Cache","defaultTTLSeconds","key","data","ttlSeconds","ttl","entry","now","cache","import_crypto","generateHash","input","isDuplicate","url1","url2","u1","u2","Fetcher","handler","options","sourceName","cacheKey","generateHash","cached","cache","memes","Filter","fetcher","import_axios","DEFAULT_USER_AGENT","HttpClient","baseURL","axios","url","config","retries","error","ms","resolve","http","RateLimiter","requestsPerSecond","key","now","lastTime","timeSinceLastRequest","waitTime","resolve","rateLimiter","SPANISH_SUBREDDITS","ENGLISH_SUBREDDITS","RedditSource","options","subreddits","shuffledSubreddits","subredditsToFetch","allMemes","subreddit","rateLimiter","sortOptions","sort","url","data","http","memes","child","meme","error","newMemes","firstId","finalUrl","isVideo","mediaType","DiscordFormatter","meme","str","limit","MemeForge","RedditSource","handler","fetcher","options","memes","meme","DiscordFormatter","results","memeForge"]}